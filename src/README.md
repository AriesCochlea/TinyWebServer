# 4种事件处理模式：


## 一、Reactor模式：使用同步IO实现
    普通的Reactor模式的主线程只负责监听所有socket文件描述符上是否有事件发生，有的话立即通知工作线程，除此之外，主线程不做任何其他实质性的工作。
    accept新连接、读写数据（send和recv）、解析客户请求和生成响应报文都在工作线程中完成。主线程中只有一个事件循环用于监听所有文件描述符上的事件。
    主线程将文件描述符上的可读或可写事件（其实是用于处理该事件的回调函数）放进任务队列中，由工作线程（如果睡眠则会被唤醒）从队列中取出并处理。
    缺点：有限数量的工作线程不能及时处理高并发下大量的用户请求，导致队列中堆积了大量的待处理请求，对客户端的响应速度将越来越慢。
          如果通过增加工作线程来解决这一问题，则线程切换的开销也会很大。
          任务队列是主线程和工作线程的共享资源，主线程往队列中添加任务、工作线程从队列中取出任务都要加锁，开销也不小，竞争关系也会导致响应变慢。



## 二、主从Reactor多线程模式：更高效的Reactor模式，也是本项目采用的事件处理模式。
    每个线程（主线程和工作线程）都有自己的事件循环，即one loop per thread，独自独立地监听不同的文件描述符上的事件。 
    所有的工作线程都不会睡眠，省去了阻塞和唤醒的开销。而且每个线程自己处理自己监听到的事件，不需要任务队列，没有加锁的开销。
    主线程负责：  监听“监听socket”上的事件、accept新连接并分发给某个工作线程（此后该新连接上所有的任务都由被选中的工作线程来负责）。
    工作线程负责：监听其负责的所有“连接socket”上的事件、读写数据（send和recv）、解析客户请求和生成响应报文。





## 三、Proactor模式：使用异步IO实现
    主线程（只在主线程中有一个事件循环）负责accept新连接、接收内核完成数据读写的信号。主线程只能监听socket上的连接请求事件，不能监听读写事件。
    内核负责读写数据（主线程调用aio_read和aio_write）并发信号通知用户进程。工作线程只负责业务逻辑：在本项目中是解析客户请求和生成响应报文。
                大致的原理流程：主线程使用异步IO函数aio_read()向内核注册文件描述符上的读事件，告诉内核用户读缓冲区的位置，
                               以及读操作完成后如何通知用户进程（以信号为例），之后主线程继续处理其他逻辑。
                               内核读完数据后，向用户进程发信号（即异步），用户进程使用预先定义好的信号处理函数将客户端请求分发给一个工作线程，
                               工作线程处理完客户请求（生成响应报文）后，调用异步IO函数aio_write()向内核注册文件描述符上的写事件，
                               并告诉内核用户写缓冲区的位置，以及写操作完成后如何通知用户进程（以信号为例）。主线程仍继续处理其他逻辑。
                               当用户写缓冲区的响应报文被内核写入socket后，内核向用户进程发送一个信号，用户进程使用信号处理函数进行善后。


## 四、模拟Proactor模式：使用同步IO模拟Proactor模式
    读写数据（send和recv）由主线程负责，读写完成后，主线程通知工作线程：将任务放进队列并notify_one工作线程：唤醒一个工作线程（如果是睡眠的）。
    相当于对Reactor模式略作修改，花里胡哨，不再赘述。









# 3种并发模式：


## 半同步/半反应堆模式：如上面的Reactor模式、模拟Proactor模式
    异步线程只有一个，就是主线程，负责监听所有socket文件描述符上的就绪事件，并将就绪的socket任务插入到任务队列。
    同步线程就是所有的工作线程，最初都睡眠在任务队列上，当有任务到来时，空闲的工作线程将通过竞争（如果获取互斥锁）来接管任务。
    半同步/半反应堆模式的缺点：有限数量的工作线程不能及时处理高并发下大量的用户请求，导致队列中堆积大量的待处理请求，对客户端的响应将越来越慢。
                             如果通过增加工作线程来解决这一问题，则线程切换的开销也会很大。任务队列是主线程和工作线程的共享资源，
                             主线程往队列中添加任务、工作线程从队列中取出任务都要加锁，开销也不小，竞争关系也会导致响应变慢。
    注：这里的“同步”和“异步”并不是指IO。“同步”指程序是否完成按照代码序列的顺序执行，“异步”指程序的执行需要由系统事件（中断、信号等）来驱动。

## 半同步/半异步模式：如上面的主从Reactor多线程模式


## 领导者/追随者模式：
    多个线程轮流选出一个线程当领导者，其他线程都是追随者，休眠在线程池中等待成为新的领导者。任意时刻，程序都只有一个领导者，负责监听IO事件。
    当前的领导者检测到IO事件后，要先从线程池中推选出新的领导者。旧领导者处理IO事件，而新领导者负责监听新的IO事件，以此来实现并发。
    优点：由于领导者线程自己处理自己监听到的事件，因此不需要在线程之间传递额外数据，也不需要任务队列和互斥锁。
    缺点：每个工作线程无法独立的管理多个客户连接，因为只支持一个事件源集合。（相当于阉割版的主从Reactor多线程模式：只有一个事件循环）





# 总结：
    更推荐使用主从Reactor多线程模式或Proactor模式，但Linux上的异步IO并不成熟，而IO多路复用epoll是业界的成熟方案。
    本项目使用的是主从Reactor多线程模式。